### [Преамблуа](#preamblua)
#### [Part 0 - Установка](#part-0)
#### [Part 1 - Готовый Докер](#part-1)
#### [Part 2 - Операции с контейнером](#part-2)
#### [Part 3 - Мини веб-сервер](#part-3)
#### [Part 4 - Свой докер](#part-4)
#### [Part 5 - Dockle](#part-5)
#### [Part 6 - Базовый Docker Compose](#part-6)

---
---

<a id="preamblua"></a>

## Чо за Docker?

- Докер использует виртуализацию на уровне ОСи, и создаёт различные контейнеры, которые изолированны друг от друга.

- Докер позволяет запихнуть приложение со всеми своими зависимостями (библиотеками типо) в стандартизированный пэкэдж в целях разработки софта

- Это open source платформа которая автоматизирует деплой, масштабирование, и мэнеджмент приложений внутри контейнеров.

- Является стандартом индустрии для контейнеризации., но не является единственным.


- Этот подход упрощает процесс деплоя приложений между различными ОСями, версиями ОСей, различными окружениями.

- **Кароч он для теста приложухи твоей, шоб оно и на яблоках, и на линуксах, и в винде фурычило нормас~**

--- 

- **Docker Hub**
    - Это облачный репозиторий.. центральный хаб где различные люди и/или организации распространяют свои контайнизированные приложения.
    
    - в Докер Хабе можно хранить как публичные так и приватные репозитории

    - Ключевые фичи Докер Хаба:
        - **Система Репозиториев**: в которой юзеры могут пушить и пулить контейнер образы.
        - **Автоматизированные билды**: Докер Хаб может интегрироваться с **GitHub** чтобы автоматом билдить и запускать твой код
        - **Webhooks** позволяет триггерить действия после успешного пуша в репо. Тоесть, позволяет интегрироваться с другими сервисами (для тестов, деплоя, и тд)
        - **Проверки безопасности**, Докер Хаб проверяет всё на вирусы и вулнарабилитиз (уязвимости)
        - **Контроль Доступа**, позволяет настроить его. bruh

    - **Эт кароч хаб где кууучи контейнеров в различных энвайроментах.**

---

- Основные понятия в **Docker**:
    - **Образ(Image)** это как-бы "установочный файл", его нельзя запустить, но можно на его основе создать контейнер.
    - **Контейнер(Container)** - экземпляр образа, "живой" образ. Тоесть в контейнере уже чтото лежит и готово к запусуку

- Предшественником **Docker** были виртуальные машины, они точно так же изолируют приложение от внешней среды. 
    - Но они лучше. Чем?
        - Потребляют меньше ресурсов машины
        - Их очень легко переносить
        - Они быстрее запускаются

- Докер образ также состоит из **слоёв**. Эта *слоевитость* играет ключевую и важную роль в процессе работы докера.

    - Слои, что это такое?
        - По сути это снэпшоты состояний файловой системы в определённых состояниях.
        - Каждый слой имеет свои конкретные конфиги и настройки, изменения в файловой системе.
        - Также - если слой создан, то он уже не может быть изменён. Это свойство неименяемости гарантирует неименяемость в разных системах, и сохранность образа.
    
    - Преимущества такой системы?
        - Эффективность, layer system позволяет переиспользовать неизменённые слои, и соответственно ускорить билдинг процесс. Только изменённые слои нужно будет ребилдить, что и сохраняет ресурсы и время. (прям как в git)

        - Занимает меньше места из-за своей логики **слоеизации**

---

Для создания образа используется **Dockerfile**, и каждая инструкиця в этом файле создаёт новый слой

---

## Список команд/флагов у **docker**:
- **docker pull [имя_образа]** - скачать образ
- **docker run [имя_образа]** - создать и запустить контейнер из образа
- **docker images** - показать образы
- **docker ps** - показать только активные контейнеры
- **docker ps -a** - показать все контейнеры, и выключенные и включенные
> Важно отметить что образы и контейнеры это разные штуки.
- **docker build .** - забилдить образ из Dockerfile
- **docker export** - экспортировать контейнер в архив, отдельный файл.
- **docker kill** - остановить включенный контейнер
- **docker logs [имя_образа]** - показать логи, ошибки и прочее от контейнера. Поможет если контейнер запускается и сразу же выключается
- **docker restart [имя_образа]** - включить/перезапустиить контейнер
- **docker rm [имя_контейнера]** - удалить контейнер
- **docker rmi [имя_образа]** - удалить образ
---
- **docker cp** - скопировать файл на контейнер
    - **docker cp ./aaa.txt mydocker:/home/user/Downloads/aaa.txt** 
        - Например скопирует файл "aaa.txt" из текущей папки в папку "Downloads" на контейнере "mydocker" 
- **docker exec** - запустить команду в запущенном образе
    - **docker exec -it mydocker sh** 
        - Например, запускает консоль (bash, sh) в интерактивном режиме (-it) на контейнере, что позволит прожимать команды прямо во включённом образе

---

## Что такое Dockle?

- Это инструмент для проверки безопасности образов контейнеров, что-то типо флага **-pedantic** при компиляции с **gcc**, ну или линтера. 
- В сути своей это проверка контейнера на уязвимости и утечки данных, и прочие ошибки


## Что такое **nginx**?
- Это open source софт для веб серверов, известный своей эффективностью, стабильностью, и набором фич. 
- Он поддерживает не только **HTTP** протокол, но и **IMAP, POP3, SMTP**, (эти трое это EMAIL протоколы)
- Обычно работа **nginx** определяется файлом конфига, и этот файл конфига обычно лежит по пути:
    - **Linux**: 
        - /etc/nginx/**nginx.conf**
    

<a id="part-0"></a>
## Part 0. Установка ВМки

- В этом проекте можно юзать любой Линукс, поэтому можно скачать самый стандартный Ubuntu, или Debian, по желанию

- Затем устанавливаем **docker** через:
    - **sudo snap install docker**

- Версия докера на которой буду делать это задание:
    - ![1](./pics/2024sept_pic1.png)

- И начинаем выполнять задание..

<a id="part-1"></a>
## Part 1. Готовый докер

##### Беру официальный докер-образ с nginx и пуллю его
- Исспользуя команду:
    - **sudo docker pull nginx** \
    - ![2](./pics/2024sept_pic2.png)

---
##### Проверяю наличие докер-образа
- Используя команду:
    - **sudo docker images** \
    - ![3](./pics/2024sept_pic3.png)

---

##### Запускаю докер образ
- Используя команду:
    - **sudo docker run -d --name mydocker nginx:latest** \
    - ![docker](./pics/2024sept_pic4.png)

    - Что за команда и что за флаг?
        - Команда запускает докер на основе образа
        - **-d** (detached mode) запускает его фоновым процессом и не лочит терминал
        - **--name** позволяет назвать контейнер по своему, а не получать рандомное имя

---

##### Проверяю, что образ запустился через
- Используя команду:
    - **sudo docker ps** \
---

##### Смотрю информацию о контейнере
- Используя команду:
    - **docker inspect mydocker** \
    - ![docker](./pics/2024sept_pic5.png)

---

##### По выводу команды определи и помести в отчёт размер контейнера, список замапленных портов и ip контейнера.
- Используя команду:
    - **docker inspect --size mydocker | grep -i -e Size -e ExposedPorts -e IPAddress -C 1**
        - Что за флаги?
            - **--size** добавляет доп информацию
            - **-i** у **grep** добавляет ignore case, регистр букв в паттерне игнорирует
            - **-C 1** у **grep** расширяет найденный вывод на 1 строку вверх и вниз \
            - **-e** у **grep** добавляет паттерны для поиска

    - ![docker](./pics/2024sept_pic6.png)

- **SizeRw** представляет собой размер изменений внесённых в образ
- **SizeRootFs** это общий размер файлов в контейнере
- **ExposedPorts** порты
- **IPAddress** это айпишник
---
##### Остановавливаю докер образ
- Через команду:
    - **sudo docker stop ###**
    ![p1](./pics/q9.png)
        - Ну и через **docker ps** сразу проверяю выключился ли он
---
##### Запускаю докер:
- Но с портами **80** и **443** в контейнере, замапленными на такие же порты на локальной машине, через команду:
    - **docker run -d -p 80:80 -p 443:443 ###** \
    ![p1](./pics/q10.png)
    - Чо за флаги?
        - **-d** запуск фоновым процессом
        - **-p [hostPort]:[containerPort]** число слева это порт **хоста** а справа это порт **контейнера**
---
##### Проверяю что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**.

- Я порт вводил! Он чтот пропадает почемут из адресной строки браузера~
    ![p1](./pics/q11.png)
---
##### Перезапускаю докер контейнер
- Используя команду:
    - **sudo docker restart ###** \
    ![p1](./pics/q12.png)
    - И сразу проверяю что он работает командой 
        - **docker ps**

<a id="part-2"></a>
## Part 2. Операции с контейнером

##### Создаю на локальной машине файл *nginx.conf*.
- На компе \
![](./pics/2024sept_pic3.png)

- Можно также проверить синтаксис nginx файла через команду:
    - **nginx -t**
- Или же этой командой, если проверяем внтури docker контейнера
    - **sudo docker exec -it --user root ### nginx -t**

---
##### Копирую созданный файл *nginx.conf* внутрь докер-образа 
##### Перезапускаю **nginx** внутри докер-образа через команду *exec*. \
- Через команды:
    - **sudo docker cp nginx.conf ###:/etc/nginx/nginx.conf** \
    - **sudo docker exec ### nginx -s reload**
    ![](./pics/2024sept_pic7.png)
    
---

- Альтернативно, можно зайти внутрь докера через:
    - **sudo docker exec -it ### sh**
    - И просто прожать:
        - **nginx -s reload**
    ![](./pics/2024sept_pic8.png)
    - Результат одинаковый что так что эдак~

---
##### Проверяю, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
- Захожу через браузер и вижу: \
![p2](./pics/q27.png)

---
##### Экспортирую контейнер в файл *container.tar* через команду:
- **sudo docker export ### > container.tar** \
    ![p2](./pics/q28.png)
    - Можно также сделать это через флаг **-o** но суть одна и та же
    - Таокй экспорт удобен для создания бэкапа, но он не сохраняет историю слоёв или метаднные. 
        - Если же надо всё это полностью сохранить, то юзать надо **sudo docker save**

---
##### Останови контейнер.
- Останавливать можно безопасно и с силой (**graceful** and **forced**)
    - **sudo docker stop ###** \
    ![p2](./pics/q29.png)
        - В данном случае происходит безопасный выход, с сохранением данных и корреткным выключением. **Но ожидание в 10 секунд**

    ---

    - **sudo docker kill ###**
        - В этом форс выключении выход происходит мгновенно, что может (а может и не можэет) иметь последствия.

---
##### Удали образ, не удаляя перед этим контейнеры, через команду:

- **sudo docker rmi --force ###** \
![p2](./pics/q30.png)
- Можно также использовать **sudo docker rmi -f ###** это просто сокращение

---
##### Удали остановленный контейнер.
- Можно использовать команду:
    -**sudo docker container prune -f**
    - Чтобы удалить все остановленные контейнеры одной командой сразу

- Но нам скорее нужно точечное удаление, тогда подходит команда:
    - **sudo docker rm [container ID]** \
    ![p2](./pics/q31.png)
    - Сначала смотрим список всех контейнеров через 
        - **sudo docker ps -a**
    - Затем удаляем не по *IMAGE* а по **CONTAINER ID**


---
##### Импортируй контейнер обратно
- Через команду:
    - **sudo docker import container.tar** \
    ![p2](./pics/q32.png)
    - Получается сначала я удалил все остановленные контейнеры через 
        - **sudo docker prune**,
    - Затем посмотрел список контейнеров через 
        - **sudo docker ps -a**
    - Импортировал ранее сохранённый **container.tar** через 
        - **sudo docker import container.tar**
    - И посмотрел импортировалось ли оно через команду:
        - **sudo docker images** \
    ![p2](./pics/q33.png)
        - Импортировалось.

---
##### Запусти импортированный контейнер.
- Через прожатие команды:
    - **docker run -d -p 80:80 ### nginx -g 'daemon off;'** \
    ![p2](./pics/q34.png)
    - Что за синтаксис в команде **docker run**?
        - **-d** detached, запуск в фоне (докера)
        - **-p 80:80** порты 80 контейнера и 80 хоста
        - **nginx** запустит нгинкс сервак
            - **-g 'daemon off;'** *global directive*, о том что *daemon off* - Тоесть запуск нгинкса не фоновым процессом а "главным", для более корректной и безошибочной работы

    - И сразу проверяю через **docker ps** и **закурливание странички** что всё запустилось

---
##### Проверяю, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
- Через браузер на ВМке \
![p2](./pics/q35.png)


<a id="part-3"></a>
## Part 3. Мини веб-сервер

> Если при попытке включить/перезапустить docker образ который в состоянии **Exited** появляется ошибка:    
>   - **error bind: address already in use**
>      - То надо через команду 
>        - **sudo lsof -i -P -n** 
>        - Найти процесс который юзает этот порт (в моём случае это был apache2) и выключить его по PID командой **sudo kill [ ID ]**

> - Также где-то в этой части была трабла из-за того что надо запускать контейнер с портами 81:81
>   - Тоесть командой:
>        - **sudo docker run -d -p 81:81 repo_name:repo_tag** 
> - И ещё, **!ВАЖНО!** лучше пробовать зайти на сайт через curl:
>   - **curl localhost:81**
>   - Или же постоянно чистить **cache** в браузере, так как браузер запоминает страничку и грузит её из кэша
---

##### Желательно создать новый контейнер
- Через команду:
    - **sudo docker run --name my_name -d -p 81:81 nginx:latest**
    ![](./pics/2024sept_pic4.png)


##### Напиши мини-сервер на **C** и **FastCgi** который будет возвращать простейшую страничку с надписью `Hello World!`.

- Создаю файлик на языке **си** \
    ![](./pics/2024sept_pic5.png)

- Копирую его на **контейнер** 
    - **sudo docker cp p3server.c ###:/etc/nginx/p3server.c**  \
    ![](./pics/2024sept_pic10.png)

---

- Далее заходим в терминал внутри докера, через:
    - **docker exec -it ### sh**
        - **-it** interactive, без этого флага терминал будет неИнтерактивен 
    - Обновляю список приложух через **apt-get update**
    - И скачиваю нужные библиотеки для поднятия мини-сервера
        - **apt-get update**
        - **apt-get install libfcgi-dev -y**
        - **apt-get install spawn-fcgi -y**
        - **apt-get install gcc -y**
        - **apt-get install php-fpm -y**
    ![](./pics/2024sept_pic9.png)

---

- Далее нахожу скопированный **си** файл в папке **etc** \
- Компилирую его и запускаю для теста \
![](./pics/2024sept_pic11.png)


##### Запускаю написанный мини-сервер через *spawn-fcgi* на порту 8080.

- Захожу в интерактивный режи на докер:
    - **sudo docker exec -it ### sh**

- И прожимаю:
    - **sudo spawn-fcgi -p 8080 a.out** \
    ![](./pics/q48.png)

---
##### Пишу свой *nginx.conf*, который будет проксировать все запросы с 81 порта на *127.0.0.1:8080*.
- Будучи в интерактивном режиме **sh** внутри контейнера, меняю **nginx.conf** на: \
    - Тут получается в папке **/etc/nginx/conf.d** файл **default.conf** был удалён (переименован в BCKP) \
    ![](./pics/q50.png)
    - Имеется только один конфиг **nginx.conf** лежащий по пути **/etc/nginx/nginx.conf**
    - И вот его внутренности: \
    ![](./pics/q51.png) 
    - По сути добавляется лишь этот код:
        > listen 81; \
        > location / { \
        >   fastcgi_pass 127.0.0.1:8080; \
        > }

---
##### Проверь, что в браузере по *localhost:81* отдается написанная тобой страничка.
- Получается нужно зайти в **sh** на контейнер и прожать:
    - **gcc p3_mini_server.c -lfcgi -o p3_server** (названия соответсвенно менять надо в соответсвии с названиями)
    - **spawn-fcgi -p 8080 ./p3_server**
    - **nginx -s reload**

- Захожу на ВМ-ке через браузер на
    - **localhost:81** \
    ![](./pics/q49.png)

##### Положи файл *nginx.conf* по пути *./nginx/nginx.conf* (это понадобится позже).
- Положил \
![](./pics/q53.png)

<a id="part-4"></a>
## Part 4. Свой докер

*При написании докер-образа избегай множественных вызовов команд RUN*

- Создаю **Dockerfile** и даю ему права на запуск **chmod +x Dockerfile** \
![](./pics/q54.png)

#### Пишу свой докер-образ, который:

##### 1) собирает исходники мини сервера на FastCgi из Part 3

##### 2) запускает его на 8080 порту;
- **spawn-fcgi -p 8080 ./p3m_server**

##### 3) копирует внутрь образа написанный *./nginx/nginx.conf*;
- **COPY ./nginx.conf /etc/nginx/nginx.conf**

##### 4) запускает **nginx**.
- **nginx -g 'daemon off;'** \
![](./pics/q55.png)

- Пометка из будушего:
    - Строчка **COPY ./start_point.sh /home/start_point.sh** оказалсь не нужна

---
##### Собери написанный докер-образ через `docker build` при этом указав имя и тег.

- Через команду:
    - **sudo docker build -t [name:tag] .**
        - да, точка тут важна. Создаёт на основе **Dockerfile** из этой папки~

    - Билд в процессе \
    ![](./pics/q56.png)

    - Билд готов \
    ![](./pics/q57.png)

---
##### Проверь через `docker images`, что все собралось корректно.
- Проверяю, всё есть: \
![](./pics/q58.png)

---
##### Запусти собранный докер-образ с маппингом 81 порта на 80 на локальной машине и маппингом папки *./nginx* внутрь контейнера по адресу, где лежат конфигурационные файлы **nginx**'а (см. [Часть 2](#part-2-операции-с-контейнером)).

- Эээ, кароч командой: 
    - **sudo docker run --name tnjn_server -d -p 80:81 -v $(pwd) p4_server:p4_ver1 sh** \
    ![](./pics/q59.png)

---
##### Проверь, что по localhost:80 доступна страничка написанного мини сервера.
- Угу пашет \
![](./pics/q60.png)

---
##### Допиши в *./nginx/nginx.conf* проксирование странички */status*, по которой надо отдавать статус сервера **nginx**.
- Дописал: \
![](./pics/q61.png)
- Конкретно вот эту часть \
![](./pics/q62.png)

- Тепепь копирую этот измененный nginx.conf внутрь образа командой
    - **docker cp  tnjn_server nginx.conf /etc/nginx/nginx.conf** \
![](./pics/q63.png)

---
##### Перезапусти докер-образ.

- Либо командой
    - **docker restart ###**

- Или же командами
    - **docker stop ###**
    - **docker start ###** \
    ![](./pics/q64.png)
        - На команду **docker save** не смотри, бес попутал~


*Если всё сделано верно, то, после сохранения файла и перезапуска контейнера, конфигурационный файл внутри докер-образа должен обновиться самостоятельно без лишних действий*
---
##### Проверь, что теперь по *localhost:80/status* отдается страничка со статусом **nginx**

- Можно всё это перезапустить ещё раз: \
![](./pics/q66.png)

- Если чтот ругается про **address already in use** то надо:
    - Установить lsof:
        - **apt-get install lsof**
    - И прожать:
        - **lsof -i -P -n**
        - Чтоб найти PID процесса который порт кушает
    - Ну и потом его 
        - **kill [PID]**

- Открывается \
![](./pics/q65.png)


<a id="part-5"></a>
## Part 5. **Dockle**

- Как его установить ваще?
    - На **MacOS** это легко, прост через **brew**
    - На **Ubuntu** ж надо зайти на:
        - **https://github.com/goodwithtech/dockle?tab=readme-ov-file#installation**
    - И там найти как установить. В моём случае это было через: \
    ![](./pics/q68.png)
    - Оно чёто там ругалось на $, но прост убираешь этот доллар и устанавливается изи~


---

##### Просканируй образ из предыдущего задания через `dockle [image_id|repository]`.

- ### Скан с ошибками: \
    ![](./pics/q70.png) \
    ![](./pics/q71.png)

##### Исправь образ так, чтобы при проверке через **dockle** не было ошибок и предупреждений.

---
- **CIS-DI-0005: Enable Content trust for Docker** чтоб это исправить надо сделать что-то из этого:
    - Сначала удалить все образы и все контейнеры через:
        - **sudo docker system prune -a**
            - (хотя можн и не удалять, прост nginx образ удалить и запулить его после прожатия следующей команды):
        - Затем уже прожимаем:
        - **export DOCKER_CONTENT_TRUST=1**
        - Потом заново **docker pull nginx** и тогда всё оки чики-пуки
    
    - Или же помогло то что я зашёл в **root** через команду **sudo -su** и прожал **export DOCKER_CONTENT_TRUST=1**? Какойто прикол был в общем связанный с тем что **export** делаем из под обычного юзера без прав на смену этой переменной
    
---
- **CIS-DI-0010: Do not store credential in environment variables/files** эта ошибка исправляется добавлением строчки при вызове **dockle**
    - **dockle -ak NGINX_GPGKEY -ak NGINX_GPGKEY_PATH [###:###]**

---
- **DKL-DI-005: Clear apt-get caches** устраняется добавлением строчки в Dockerfile
    - **rm -rf /var/lib/apt/lists**

---
- **CIS-DI-0001: Create a user for the container** испрявляется добавлением юзера командой в Dockerfile
    - **useradd [name]**

---
- **CIS-DI-0006: Add HEALTHCHECK instruction to the container image** испрявляется добавлением цели HEALTHCHECK в Dockerfile

---
- **CIS_DI-0008: Confirm safety of setuid/setgid files** исправляется тоже прожатием команд доступа в Dockerfile, нужно заметить что права где-то **g-s** а где то **u-s**

---
- Можно также добавить к вызову **dockle** флаг -i (ignore) и код ошибки, чтобы игнорировать её. Это не исправление как таковое, но по заданию ведь нужно чтобы **dockle** не ругался, правда?
    - Пример использования:
        - **dockle -ak NGINX_GPGKEY -ak NGINX_GPGKEY_PATH -i CIS-DI-0005 [###:###]**

- Исправленный **Dockerfile** \
![](./pics/g5.png)

- Билдю через команду:
    - **sudo docker build -t [###:###] .** \

- Проверяю заного:
    ![](./pics/g1.png)
    ![](./pics/g6.png)
    - **dockle** ничего не пишет в ответ, значит всё пофикшено

<a id="part-6"></a>
## Part 6. Базовый **Docker Compose**

<!--
- В этой части очень поможет утилита **yamllint** которую можно установить или чекать **docker-compose.yml** файлик онлайн, через одноимённый веб-сайт. 

- Что такое docker compose? В чём смысл?
    - Это как Dockerfile для Dockerfile'ов, инструмент для запуска мульти-контейнеров.
    - Позволяет запускать/останавливать несколько контейнеров сразу.
---

- **docker-compose up:**
    - Это команда запуска того что написано в **docker-compose.yml**, по сути она:
        - Билдит образы (images)
        - Создаёт контейнеры (containers)
        - Запускает контейнеры. Запускает все контейнеры паралельно, если нет директивы "depends_on"
        - Начинает вести логи о состоянии сразу на консоль/терминал
            - Можно запускать через **docker-compose up -d** в detached режиме~

---
##### Напиши файл *docker-compose.yml*, с помощью которого:
##### 1) Подними докер-контейнер из [Части 5]

##### 2) Подними докер-контейнер с **nginx**, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.
##### Замапь 8080 порт второго контейнера на 80 порт локальной машины.
- Написанный **yml** файл \
![](./pics/2024july_p2.png)

---
##### Останови все запущенные контейнеры.
- Командой:
    - **sudo docker stop $(docker ps -a -q)** \
![](./pics/2024july_p3.png)

---
##### Собери и запусти проект с помощью команд `docker-compose build` и `docker-compose up`.
- Прожимаю команды \
![](./pics/2024july_p4.png)


---
##### Проверь, что в браузере по *localhost:80* отдается написанная тобой страничка, как и ранее.
![zaglushka](./pics/)
-->

### EOF